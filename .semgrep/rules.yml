rules:
  - id: no-panic-in-library
    pattern: panic(...)
    message: >
      Libraries must not call panic(). Return an error to callers instead.
    languages: [go]
    severity: ERROR
    paths:
      exclude:
        - "*_test.go"

  - id: no-log-in-library
    patterns:
      - pattern: log.Print(...)
      - pattern: log.Printf(...)
      - pattern: log.Println(...)
      - pattern: log.Fatal(...)
      - pattern: log.Fatalf(...)
      - pattern: log.Fatalln(...)
      - pattern: log.Panic(...)
      - pattern: log.Panicf(...)
      - pattern: log.Panicln(...)
    message: >
      Libraries must not call log functions. Let the caller handle logging.
    languages: [go]
    severity: ERROR
    paths:
      exclude:
        - "*_test.go"

  - id: no-os-exit-in-library
    pattern: os.Exit(...)
    message: >
      Libraries must not call os.Exit(). Return an error to callers instead.
    languages: [go]
    severity: ERROR
    paths:
      exclude:
        - "*_test.go"

  - id: errorf-wrap-with-w
    patterns:
      - pattern: fmt.Errorf($FMT, ..., $ERR)
      - metavariable-regex:
          metavariable: $ERR
          regex: "^err$|^.*[Ee]rr$|^.*[Ee]rror$"
      - metavariable-regex:
          metavariable: $FMT
          regex: ".*(%s|%v).*"
    message: >
      Use %w instead of %s or %v when wrapping an error with fmt.Errorf.
      This preserves the error chain for errors.Is / errors.As.
    languages: [go]
    severity: ERROR

  # ── Mutex-safety rules ──────────────────────────────────────────────────────
  #
  # These rules were derived from a full audit of client.go, server.go,
  # stream.go, subscriber.go, http.go, event.go, and event_log.go.
  #
  # Key findings that motivated these rules:
  #
  # 1. c.Connected (plain bool) was read/written without synchronisation from
  #    multiple goroutines (SubscribeWithContext, SubscribeChanWithContext,
  #    readLoop). Fixed by converting to atomic.Bool.
  #
  # 2. The patterns below are potential lock-safety hazards that would introduce
  #    bugs in future changes.  No current production bug exists for rules 2-4,
  #    but the rules enforce forward-safe patterns.
  #
  # Design notes:
  #   - Short critical sections (Lock + 1-2 stmts + Unlock, no return between
  #     them) are intentionally NOT deferred and must NOT be flagged.
  #   - The pattern-not clauses below exclude exactly these safe patterns.
  #   - Rules are excluded from test files to avoid noise on test helpers.

  # Rule M1: Lock() with early return but no defer Unlock().
  # An early return inside the locked region leaves the mutex permanently locked.
  # Safe patterns excluded:
  #   (a) Lock + defer Unlock (the standard safe pattern)
  #   (b) Lock + ... + Unlock + ... + return (unlock before return is fine)
  - id: lock-without-defer
    patterns:
      - pattern: |
          $MU.Lock()
          ...
          return $X
      - pattern-not: |
          $MU.Lock()
          defer $MU.Unlock()
          ...
          return $X
      - pattern-not: |
          $MU.Lock()
          ...
          $MU.Unlock()
          ...
          return $X
    message: >
      Lock() called without an immediate defer Unlock() and the function has
      a return statement. An early return before the matching Unlock() will
      leave the mutex permanently locked.
      Fix: add 'defer $MU.Unlock()' immediately after the Lock() call, or
      ensure every return path is preceded by an explicit Unlock().
    languages: [go]
    severity: ERROR
    paths:
      exclude:
        - "*_test.go"

  # Rule M2: RLock() with early return but no defer RUnlock().
  # Same hazard as M1 but for read-locks.
  - id: rwmutex-rlock-without-defer
    patterns:
      - pattern: |
          $MU.RLock()
          ...
          return $X
      - pattern-not: |
          $MU.RLock()
          defer $MU.RUnlock()
          ...
          return $X
      - pattern-not: |
          $MU.RLock()
          ...
          $MU.RUnlock()
          ...
          return $X
    message: >
      RLock() called without an immediate defer RUnlock() and the function
      has a return statement. An early return before the matching RUnlock()
      will leave the read-lock permanently held, blocking all writers.
      Fix: add 'defer $MU.RUnlock()' immediately after the RLock() call.
    languages: [go]
    severity: ERROR
    paths:
      exclude:
        - "*_test.go"

  # Rule M3: Channel send between manual Lock/Unlock (not deferred).
  # If the goroutine reading from the channel also needs this lock, it deadlocks.
  # Real example: Unsubscribe() in client.go holds c.mu while sending to a
  # buffered channel; safe because it uses select-with-default, but a blocking
  # send would deadlock.
  - id: channel-send-while-locked
    patterns:
      - pattern: |
          $MU.Lock()
          ...
          $CH <- $VAL
          ...
          $MU.Unlock()
      - pattern-not: |
          $MU.Lock()
          defer $MU.Unlock()
          ...
          $CH <- $VAL
    message: >
      Channel send ('$CH <- $VAL') occurs between a manual Lock() and
      Unlock() (not deferred). If the goroutine reading from $CH also tries
      to acquire the same lock, this will deadlock.
      Fix: release the lock before the send, or ensure the send is
      non-blocking (select with default).
    languages: [go]
    severity: ERROR
    paths:
      exclude:
        - "*_test.go"

  # Rule M4: Goroutine spawned between manual Lock/Unlock (not deferred).
  # If the spawned goroutine acquires the same lock it will deadlock immediately
  # because the parent still holds it until Unlock() is reached.
  - id: goroutine-spawned-while-locked
    patterns:
      - pattern: |
          $MU.Lock()
          ...
          go $FUNC(...)
          ...
          $MU.Unlock()
      - pattern-not: |
          $MU.Lock()
          defer $MU.Unlock()
          ...
          go $FUNC(...)
      - pattern-not: |
          $MU.Lock()
          ...
          $MU.Unlock()
          ...
          go $FUNC(...)
    message: >
      Goroutine spawned ('go $FUNC(...)') between a manual Lock() and
      Unlock() (not deferred). If the goroutine acquires the same lock it
      will deadlock immediately.
      Fix: move the 'go' statement after Unlock(), or use defer.
    languages: [go]
    severity: ERROR
    paths:
      exclude:
        - "*_test.go"

  # ── Go library idiom rules ───────────────────────────────────────────────────

  # Rule L1: Hardcoded channel buffer sizes.
  # Channel buffers larger than 1 should be named constants so that their
  # purpose is documented and they can be tuned in one place.
  # Buffer of 1 ("at-most-one-pending") is idiomatic and excluded.
  # Zero (unbuffered) is fine and excluded automatically (no second argument).
  - id: no-hardcoded-channel-buffer
    pattern-regex: 'make\(chan\s+[^,)]+,\s*(?:[2-9]\d*|\d{2,})\s*\)'
    message: >
      Hardcoded channel buffer size greater than 1. Define a named constant
      (e.g. const subscriberChanBuf = 64) so the value is documented and
      tunable in one place.
    languages: [go]
    severity: WARNING
    paths:
      exclude:
        - "*_test.go"

  # Rule L2: Blocking channel send inside an index-based or range for loop.
  # A direct 'ch <- val' inside an iteration loop will block indefinitely if
  # the receiver is slow or the channel is full. This is the typical hazard in
  # fan-out / replay loops where the loop visits every subscriber or log entry.
  # Event loops (for { select { } }) are intentionally excluded — those are
  # the correct pattern for a concurrent goroutine waiting on multiple channels.
  - id: blocking-channel-send-in-iteration-loop
    patterns:
      - pattern-either:
          - pattern: |
              for $I = 0; ...; $I++ {
                ...
                $CH <- $VAL
                ...
              }
          - pattern: |
              for $I := 0; ...; $I++ {
                ...
                $CH <- $VAL
                ...
              }
          - pattern: |
              for _, $V := range $SLICE {
                ...
                $CH <- $VAL
                ...
              }
          - pattern: |
              for $V := range $SLICE {
                ...
                $CH <- $VAL
                ...
              }
      - pattern-not-inside: |
          select {
          case $CH <- $VAL:
            ...
          }
    message: >
      Blocking channel send ('$CH <- $VAL') inside an iteration loop with no
      select guard. If $CH is full or the receiver is slow this loop will stall
      indefinitely, blocking the calling goroutine.
      Fix: wrap the send in 'select { case $CH <- $VAL: ... default: ... }'
      or add a quit-channel case so the loop can always make progress.
    languages: [go]
    severity: WARNING
    paths:
      exclude:
        - "*_test.go"
